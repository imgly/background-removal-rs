//! Build script for generating model configuration constants from model.json
//! Updated for rescale factor support

#![allow(missing_docs)]
#![allow(clippy::too_many_lines)]
#![allow(clippy::expect_used)]
#![allow(clippy::unwrap_used)]
#![allow(clippy::indexing_slicing)]
#![allow(clippy::panic)]
#![allow(clippy::format_push_string)]

use std::env;
use std::fs;
use std::path::Path;

fn main() {
    println!("cargo:rerun-if-changed=../../models");

    let out_dir = env::var("OUT_DIR").expect("OUT_DIR environment variable not set");
    let dest_path = Path::new(&out_dir).join("model_config.rs");

    // Get all embedded models based on features
    let embedded_models = get_embedded_models();

    if embedded_models.is_empty() {
        // No embedded models - generate empty registry
        let generated_code = r"
// Generated by build.rs - do not edit manually
// No embedded models configured

#[derive(Debug, Clone)]
pub struct EmbeddedModelData {
    pub name: String,
    pub model_data: Vec<u8>,
    pub input_name: String,
    pub output_name: String,
    pub input_shape: [usize; 4],
    pub output_shape: [usize; 4],
    pub preprocessing: PreprocessingConfig,
}

#[derive(Debug, Clone)]
pub struct PreprocessingConfig {
    pub target_size: [u32; 2],
    pub normalization_mean: [f32; 3],
    pub normalization_std: [f32; 3],
}

pub struct EmbeddedModelRegistry;

impl EmbeddedModelRegistry {
    #[must_use] pub fn get_model(_name: &str) -> Option<EmbeddedModelData> {
        None // No embedded models
    }
    
    #[must_use] pub fn list_available() -> &'static [&'static str] {
        &[] // Empty list
    }
}
";
        fs::write(&dest_path, generated_code).expect("Failed to write generated code");
        return;
    }

    // Generate model loader functions and registry
    let mut generated_code = String::from(
        r"
// Generated by build.rs - do not edit manually

#[derive(Debug, Clone)]
pub struct EmbeddedModelData {
    pub name: String,
    pub model_data: Vec<u8>,
    pub input_name: String,
    pub output_name: String,
    pub input_shape: [usize; 4],
    pub output_shape: [usize; 4],
    pub preprocessing: PreprocessingConfig,
}

#[derive(Debug, Clone)]
pub struct PreprocessingConfig {
    pub target_size: [u32; 2],
    pub normalization_mean: [f32; 3],
    pub normalization_std: [f32; 3],
}

",
    );

    // Generate model loader functions
    for (model_id, model_name, variant) in &embedded_models {
        let model_config = load_model_config(model_name);
        let variant_config = model_config["variants"][variant]
            .as_object()
            .unwrap_or_else(|| panic!("Variant '{variant}' not found in model '{model_name}'"));
        let preprocessing = &model_config["preprocessing"];

        let input_shape = variant_config["input_shape"].as_array().unwrap_or_else(|| {
            panic!("input_shape not found or not an array for {model_name}:{variant}")
        });
        let output_shape = variant_config["output_shape"]
            .as_array()
            .unwrap_or_else(|| {
                panic!("output_shape not found or not an array for {model_name}:{variant}")
            });
        let input_name = variant_config["input_name"].as_str().unwrap_or_else(|| {
            panic!("input_name not found or not a string for {model_name}:{variant}")
        });
        let output_name = variant_config["output_name"].as_str().unwrap_or_else(|| {
            panic!("output_name not found or not a string for {model_name}:{variant}")
        });

        let target_size = preprocessing["target_size"]
            .as_array()
            .unwrap_or_else(|| panic!("target_size not found or not an array for {model_name}"));
        let mean = preprocessing["normalization"]["mean"]
            .as_array()
            .unwrap_or_else(|| {
                panic!("normalization mean not found or not an array for {model_name}")
            });
        let std = preprocessing["normalization"]["std"]
            .as_array()
            .unwrap_or_else(|| {
                panic!("normalization std not found or not an array for {model_name}")
            });

        // Use workspace root to locate models directory
        let workspace_root = env::var("CARGO_MANIFEST_DIR")
            .expect("CARGO_MANIFEST_DIR not set")
            .replace("/crates/bg-remove-core", ""); // Remove the crate subdirectory
        let model_path = format!("{}/models/{}/model_{}.onnx", workspace_root, model_name, variant);
        let function_name = format!("load_{}", model_id.replace('-', "_"));

        generated_code.push_str(&format!(
            "
#[must_use] fn {}() -> EmbeddedModelData {{
    EmbeddedModelData {{
        name: \"{}\".to_string(),
        model_data: include_bytes!(\"{}\").to_vec(),
        input_name: \"{}\".to_string(),
        output_name: \"{}\".to_string(),
        input_shape: [{}, {}, {}, {}],
        output_shape: [{}, {}, {}, {}],
        preprocessing: PreprocessingConfig {{
            target_size: [{}, {}],
            normalization_mean: [{:.1}, {:.1}, {:.1}],
            normalization_std: [{:.1}, {:.1}, {:.1}],
        }},
    }}
}}
",
            function_name,
            model_id,
            model_path,
            input_name,
            output_name,
            input_shape[0].as_u64().unwrap_or_default(),
            input_shape[1].as_u64().unwrap_or_default(),
            input_shape[2].as_u64().unwrap_or_default(),
            input_shape[3].as_u64().unwrap_or_default(),
            output_shape[0].as_u64().unwrap_or_default(),
            output_shape[1].as_u64().unwrap_or_default(),
            output_shape[2].as_u64().unwrap_or_default(),
            output_shape[3].as_u64().unwrap_or_default(),
            target_size[0].as_u64().unwrap_or_default(),
            target_size[1].as_u64().unwrap_or_default(),
            mean[0].as_f64().unwrap_or(0.0),
            mean[1].as_f64().unwrap_or(0.0),
            mean[2].as_f64().unwrap_or(0.0),
            std[0].as_f64().unwrap_or(1.0),
            std[1].as_f64().unwrap_or(1.0),
            std[2].as_f64().unwrap_or(1.0)
        ));
    }

    // Generate registry implementation
    generated_code += "pub struct EmbeddedModelRegistry;\n\n";
    generated_code += "impl EmbeddedModelRegistry {\n";
    generated_code +=
        "    #[must_use] pub fn get_model(name: &str) -> Option<EmbeddedModelData> {\n";
    generated_code += "        match name {\n";

    for (model_id, _, _) in &embedded_models {
        let function_name = format!("load_{}", model_id.replace('-', "_"));
        generated_code += &format!("            \"{model_id}\" => Some({function_name}()),\n");
    }

    generated_code += "            _ => None,\n";
    generated_code += "        }\n";
    generated_code += "    }\n";

    // Generate list_available function
    generated_code +=
        "    \n    #[must_use] pub fn list_available() -> &'static [&'static str] {\n";
    generated_code += "        &[";
    for (i, (model_id, _, _)) in embedded_models.iter().enumerate() {
        if i > 0 {
            generated_code += ", ";
        }
        generated_code += &format!("\"{model_id}\"");
    }
    generated_code += "]\n";
    generated_code += "    }\n";
    generated_code += "}\n";

    fs::write(&dest_path, generated_code).expect("Failed to write generated code");
}

fn get_embedded_models() -> Vec<(String, String, String)> {
    let mut models = Vec::new();

    // Check for each embedded model feature
    if cfg!(feature = "embed-isnet-fp16") {
        models.push((
            "isnet-fp16".to_string(),
            "isnet".to_string(),
            "fp16".to_string(),
        ));
    }
    if cfg!(feature = "embed-isnet-fp32") {
        models.push((
            "isnet-fp32".to_string(),
            "isnet".to_string(),
            "fp32".to_string(),
        ));
    }
    if cfg!(feature = "embed-birefnet-fp16") {
        models.push((
            "birefnet-fp16".to_string(),
            "birefnet_portrait".to_string(),
            "fp16".to_string(),
        ));
    }
    if cfg!(feature = "embed-birefnet-fp32") {
        models.push((
            "birefnet-fp32".to_string(),
            "birefnet_portrait".to_string(),
            "fp32".to_string(),
        ));
    }
    if cfg!(feature = "embed-birefnet-lite-fp32") {
        models.push((
            "birefnet-lite-fp32".to_string(),
            "birefnet_lite".to_string(),
            "fp32".to_string(),
        ));
    }

    models
}

fn load_model_config(model_name: &str) -> serde_json::Value {
    // Use CARGO_MANIFEST_DIR to get absolute path to the crate root
    let manifest_dir = env::var("CARGO_MANIFEST_DIR").expect("CARGO_MANIFEST_DIR not set");
    let model_json_path = format!("{manifest_dir}/../../models/{model_name}/model.json");
    let json_content = fs::read_to_string(&model_json_path).unwrap_or_else(|_| {
        panic!("Failed to read model.json for model '{model_name}' at path: {model_json_path}")
    });

    serde_json::from_str(&json_content)
        .unwrap_or_else(|_| panic!("Failed to parse model.json for model '{model_name}'"))
}
