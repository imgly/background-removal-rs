//! Build script for generating model configuration constants from model.json
//! Updated for rescale factor support

#![allow(missing_docs)]

use std::env;
use std::fs;
use std::path::Path;

fn main() {
    println!("cargo:rerun-if-changed=../../models");
    
    let out_dir = env::var("OUT_DIR").unwrap();
    let dest_path = Path::new(&out_dir).join("model_config.rs");
    
    // Get all embedded models based on features
    let embedded_models = get_embedded_models();
    
    if embedded_models.is_empty() {
        // No embedded models - generate empty registry
        let generated_code = r#"
// Generated by build.rs - do not edit manually
// No embedded models configured

#[derive(Debug, Clone)]
pub struct EmbeddedModelData {
    pub name: String,
    pub model_data: Vec<u8>,
    pub input_name: String,
    pub output_name: String,
    pub input_shape: [usize; 4],
    pub output_shape: [usize; 4],
    pub preprocessing: PreprocessingConfig,
}

#[derive(Debug, Clone)]
pub struct PreprocessingConfig {
    pub target_size: [u32; 2],
    pub normalization_mean: [f32; 3],
    pub normalization_std: [f32; 3],
}

pub struct EmbeddedModelRegistry;

impl EmbeddedModelRegistry {
    pub fn get_model(_name: &str) -> Option<EmbeddedModelData> {
        None // No embedded models
    }
    
    pub fn list_available() -> &'static [&'static str] {
        &[] // Empty list
    }
}
"#;
        fs::write(&dest_path, generated_code).unwrap();
        return;
    }
    
    // Generate model loader functions and registry
    let mut generated_code = String::from(r#"
// Generated by build.rs - do not edit manually

#[derive(Debug, Clone)]
pub struct EmbeddedModelData {
    pub name: String,
    pub model_data: Vec<u8>,
    pub input_name: String,
    pub output_name: String,
    pub input_shape: [usize; 4],
    pub output_shape: [usize; 4],
    pub preprocessing: PreprocessingConfig,
}

#[derive(Debug, Clone)]
pub struct PreprocessingConfig {
    pub target_size: [u32; 2],
    pub normalization_mean: [f32; 3],
    pub normalization_std: [f32; 3],
}

"#);

    // Generate model loader functions
    for (model_id, model_name, variant) in &embedded_models {
        let model_config = load_model_config(model_name);
        let variant_config = model_config["variants"][variant].as_object()
            .expect(&format!("Variant '{}' not found in model '{}'", variant, model_name));
        let preprocessing = &model_config["preprocessing"];
        
        let input_shape = &variant_config["input_shape"];
        let output_shape = &variant_config["output_shape"];
        let input_name = variant_config["input_name"].as_str().unwrap();
        let output_name = variant_config["output_name"].as_str().unwrap();
        
        let target_size = &preprocessing["target_size"];
        let mean = &preprocessing["normalization"]["mean"];
        let std = &preprocessing["normalization"]["std"];
        
        let model_path = format!("../../../../../models/{}/model_{}.onnx", model_name, variant);
        let function_name = format!("load_{}", model_id.replace("-", "_"));
        
        generated_code.push_str(&format!(r#"
fn {}() -> EmbeddedModelData {{
    EmbeddedModelData {{
        name: "{}".to_string(),
        model_data: include_bytes!("{}").to_vec(),
        input_name: "{}".to_string(),
        output_name: "{}".to_string(),
        input_shape: [{}, {}, {}, {}],
        output_shape: [{}, {}, {}, {}],
        preprocessing: PreprocessingConfig {{
            target_size: [{}, {}],
            normalization_mean: [{}, {}, {}],
            normalization_std: [{}, {}, {}],
        }},
    }}
}}
"#,
            function_name,
            model_id,
            model_path,
            input_name,
            output_name,
            input_shape[0], input_shape[1], input_shape[2], input_shape[3],
            output_shape[0], output_shape[1], output_shape[2], output_shape[3],
            target_size[0], target_size[1],
            mean[0], mean[1], mean[2],
            std[0], std[1], std[2]
        ));
    }
    
    // Generate registry implementation
    generated_code.push_str("pub struct EmbeddedModelRegistry;\n\n");
    generated_code.push_str("impl EmbeddedModelRegistry {\n");
    generated_code.push_str("    pub fn get_model(name: &str) -> Option<EmbeddedModelData> {\n");
    generated_code.push_str("        match name {\n");
    
    for (model_id, _, _) in &embedded_models {
        let function_name = format!("load_{}", model_id.replace("-", "_"));
        generated_code.push_str(&format!("            \"{}\" => Some({}()),\n", model_id, function_name));
    }
    
    generated_code.push_str("            _ => None,\n");
    generated_code.push_str("        }\n");
    generated_code.push_str("    }\n");
    
    // Generate list_available function
    generated_code.push_str("    \n    pub fn list_available() -> &'static [&'static str] {\n");
    generated_code.push_str("        &[");
    for (i, (model_id, _, _)) in embedded_models.iter().enumerate() {
        if i > 0 { generated_code.push_str(", "); }
        generated_code.push_str(&format!("\"{}\"", model_id));
    }
    generated_code.push_str("]\n");
    generated_code.push_str("    }\n");
    generated_code.push_str("}\n");
    
    fs::write(&dest_path, generated_code).unwrap();
}

fn get_embedded_models() -> Vec<(String, String, String)> {
    let mut models = Vec::new();
    
    // Check for each embedded model feature
    if cfg!(feature = "embed-isnet-fp16") {
        models.push(("isnet-fp16".to_string(), "isnet".to_string(), "fp16".to_string()));
    }
    if cfg!(feature = "embed-isnet-fp32") {
        models.push(("isnet-fp32".to_string(), "isnet".to_string(), "fp32".to_string()));
    }
    if cfg!(feature = "embed-birefnet-fp16") {
        models.push(("birefnet-fp16".to_string(), "birefnet_portrait".to_string(), "fp16".to_string()));
    }
    if cfg!(feature = "embed-birefnet-fp32") {
        models.push(("birefnet-fp32".to_string(), "birefnet_portrait".to_string(), "fp32".to_string()));
    }
    if cfg!(feature = "embed-birefnet-lite-fp32") {
        models.push(("birefnet-lite-fp32".to_string(), "birefnet_lite".to_string(), "fp32".to_string()));
    }
    
    models
}

fn load_model_config(model_name: &str) -> serde_json::Value {
    // Use CARGO_MANIFEST_DIR to get absolute path to the crate root
    let manifest_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
    let model_json_path = format!("{}/../../models/{}/model.json", manifest_dir, model_name);
    let json_content = fs::read_to_string(&model_json_path)
        .expect(&format!("Failed to read model.json for model '{}' at path: {}", model_name, model_json_path));
    
    serde_json::from_str(&json_content)
        .expect(&format!("Failed to parse model.json for model '{}'", model_name))
}