//! Build script for generating model configuration constants from model.json
//! Updated for rescale factor support

#![allow(missing_docs)]

use std::env;
use std::fs;
use std::path::Path;

fn main() {
    println!("cargo:rerun-if-changed=../../models");
    
    let out_dir = env::var("OUT_DIR").unwrap();
    let dest_path = Path::new(&out_dir).join("model_config.rs");
    
    // Determine which model and variant to use based on features
    let model_name = determine_model_from_features();
    let variant = determine_variant_from_features();
    
    // Load and parse model.json
    let model_config = load_model_config(&model_name);
    let variant_config = model_config["variants"][&variant].as_object()
        .expect(&format!("Variant '{}' not found in model '{}'", variant, model_name));
    let preprocessing = &model_config["preprocessing"];
    
    // Extract configuration values
    let input_shape = &variant_config["input_shape"];
    let output_shape = &variant_config["output_shape"];
    let input_name = variant_config["input_name"].as_str().unwrap();
    let output_name = variant_config["output_name"].as_str().unwrap();
    
    let target_size = &preprocessing["target_size"];
    let mean = &preprocessing["normalization"]["mean"];
    let std = &preprocessing["normalization"]["std"];
    
    
    // Generate the constants file - path from build output directory to workspace root
    let model_path = format!("../../../../../models/{}/model_{}.onnx", model_name, variant);
    let generated_code = format!(r#"
// Generated by build.rs - do not edit manually

/// Model name selected at compile time
pub const EMBEDDED_MODEL_NAME: &str = "{}";

/// Model variant selected at compile time  
pub const EMBEDDED_MODEL_VARIANT: &str = "{}";

/// Load embedded model data at compile time
pub fn load_embedded_model() -> Vec<u8> {{
    include_bytes!("{}").to_vec()
}}

/// Input tensor name for ONNX inference
pub const EMBEDDED_INPUT_NAME: &str = "{}";

/// Output tensor name for ONNX inference  
pub const EMBEDDED_OUTPUT_NAME: &str = "{}";

/// Model input shape (NCHW format)
pub const EMBEDDED_INPUT_SHAPE: [usize; 4] = [{}, {}, {}, {}];

/// Model output shape (NCHW format)
pub const EMBEDDED_OUTPUT_SHAPE: [usize; 4] = [{}, {}, {}, {}];

/// Preprocessing target size [width, height]
pub const EMBEDDED_TARGET_SIZE: [u32; 2] = [{}, {}];

/// Normalization mean values [R, G, B]
pub const EMBEDDED_NORMALIZATION_MEAN: [f32; 3] = [{}, {}, {}];

/// Normalization std values [R, G, B]  
pub const EMBEDDED_NORMALIZATION_STD: [f32; 3] = [{}, {}, {}];
"#,
        model_name,
        variant,
        model_path,
        input_name,
        output_name,
        input_shape[0], input_shape[1], input_shape[2], input_shape[3],
        output_shape[0], output_shape[1], output_shape[2], output_shape[3],
        target_size[0], target_size[1],
        mean[0], mean[1], mean[2],
        std[0], std[1], std[2]
    );
    
    fs::write(&dest_path, generated_code).unwrap();
}

fn determine_model_from_features() -> String {
    if cfg!(feature = "model-birefnet") {
        "birefnet_portrait".to_string()
    } else if cfg!(feature = "model-isnet") {
        "isnet".to_string()
    } else {
        // Default to ISNet for backward compatibility
        "isnet".to_string()
    }
}

fn determine_variant_from_features() -> String {
    if cfg!(feature = "precision-fp32") {
        "fp32".to_string()
    } else if cfg!(feature = "precision-fp16") {
        "fp16".to_string()
    } else {
        panic!("No model precision feature enabled. Enable either 'precision-fp16' or 'precision-fp32'");
    }
}

fn load_model_config(model_name: &str) -> serde_json::Value {
    // Use CARGO_MANIFEST_DIR to get absolute path to the crate root
    let manifest_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
    let model_json_path = format!("{}/../../models/{}/model.json", manifest_dir, model_name);
    let json_content = fs::read_to_string(&model_json_path)
        .expect(&format!("Failed to read model.json for model '{}' at path: {}", model_name, model_json_path));
    
    serde_json::from_str(&json_content)
        .expect(&format!("Failed to parse model.json for model '{}'", model_name))
}